\documentclass[a4paper,10pt]{report}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xspace}
\pagestyle{headings}
%\usepackage[margin=1.2in]{geometry}
\usepackage[left=2cm, right=2cm, top=2.5cm, bottom=2cm]{geometry}
\usepackage{float}
\restylefloat{table}
\usepackage{listings}
\usepackage{color}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.58}
\definecolor{attributeColor}{rgb}{0.96,0.517,0.29}
\definecolor{darkgreen}{rgb}{0,.392,0}
\definecolor{stringColor}{rgb}{0.6,0.2,0}
\usepackage{array,multirow}
\usepackage{longtable}
\usepackage{cleveref}
\usepackage{bbding}
\crefname{section}{¤}{¤¤}
\Crefname{section}{¤}{¤¤}
\usepackage[utf8]{inputenc}
\usepackage{tablefootnote}
\usepackage{algorithmic}

\newcommand{\myStartLine}{\par
  \kern8pt % space above the rules
  \hrule height 0.5pt
  \kern3pt % space below the rules
}
\newcommand{\myEndLine}{\par
  \kern3pt % space above the rules
  \hrule height 1.5pt
  \kern12pt % space below the rules
}

%\lstset{
%  basicstyle=\ttfamily,
%  columns=fullflexible,
%  showstringspaces=false,
%  commentstyle=\color{gray}\upshape
%  numbers=left,
%%  frame = single, 
%%  stepnumber=5
%}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily\footnotesize,
  morestring=[b]",
  morestring=[s]{>}{<},
  moredelim=[s][\bfseries\color{darkblue}]{<}{\ },
  moredelim=[s][\bfseries\color{darkblue}]{</}{>},
  moredelim=[l][\bfseries\color{darkblue}]{/>},
  moredelim=[l][\bfseries\color{darkblue}]{>},
  morecomment=[s]{<?}{?>},
  morecomment=[s]{<![CDATA[}{]]>},
  moredelim=[s][\bfseries\color{darkgreen}]{<!--}{-->},
  commentstyle=\color{darkgreen},
  stringstyle=\color{stringColor},
  identifierstyle=\color{red},
  keywordstyle=\color{attributeColor},
  morekeywords={oid,columnId,columnIdRef,symbId,symbolType,op,columnNum,columnType,
  valueType,inputTarget,blkId,blkIdRef,symbIdRef,xmlns,version,type,VariableMapping,
  IndividualMapping,schemaLocation,xs,xsi,NONMEMdataSet,matrixType,opType,order,
  math,ct,ds,mdef,mstep,mml,un,name,definition,writtenVersion,id,inputType,oidRef,catId,
  length,default,vectorIndex,diagDefault,offDiagDefault,row,column,numbRows,numbCols,
  dataSymbol,modelSymbol,ordered,compartmentNo,compNo,ordered,linkFunction,varId,
  censoringType,dataSymbol,modelSymbol,MarkovOrder,deviationMatrixType,implementedBy,
  argument,admNumber} % list your attributes here
}

\lstdefinelanguage{MLXTRANcode} 
{
  basicstyle=\ttfamily\footnotesize,
  morestring=[b]",
  morestring=[s]{>}{<},
  moredelim=[s][\bfseries\color{darkblue}]{<}{\ },
  moredelim=[s][\bfseries\color{darkblue}]{</}{>},
  moredelim=[l][\bfseries\color{darkblue}]{/>},
  moredelim=[l][\bfseries\color{darkblue}]{>},
  morecomment=[s]{<?}{?>},
  morecomment=[s]{<!--}{-->},
  morecomment=[s]{<![CDATA[}{]]>},
  commentstyle=\color{darkgreen},
  stringstyle=\color{stringColor},
  identifierstyle=\color{black},
  keywordstyle=\color{attributeColor},
  morekeywords={dads} % list your attributes here
}

\lstdefinelanguage{NONMEMdataSet}
{
  basicstyle=\ttfamily\footnotesize,
  morestring=[b]",
  morestring=[s]{>}{<},
  moredelim=[s][\bfseries\color{darkblue}]{<}{\ },
  moredelim=[s][\bfseries\color{darkblue}]{</}{>},
  moredelim=[l][\bfseries\color{darkblue}]{/>},
  moredelim=[l][\bfseries\color{darkblue}]{>},
  morecomment=[s]{<?}{?>},
  morecomment=[s]{<!--}{-->},
  morecomment=[s]{<![CDATA[}{]]>},
  commentstyle=\color{darkgreen},
  stringstyle=\color{stringColor},
  identifierstyle=\color{black},
  keywordstyle=\color{attributeColor},
  morekeywords={kjkj} % list your attributes here
}


\newcommand{\cellml}{CellML\xspace}
\newcommand{\sbml}{SBML\xspace}
\newcommand{\sedml}{SED-ML\xspace}
\newcommand{\mathml}{MathML\xspace}
\newcommand{\uncertml}{UncertML\xspace}
\newcommand{\pml}{PharmML\xspace}
\newcommand{\pharmml}{PharmML\xspace}
\newcommand{\xelem}[1]{\texttt{<#1>}\index{XML Element!\texttt{<#1>}}}
\newcommand{\xatt}[1]{\texttt{#1}\index{XML Attribute!\texttt{#1}}}

\begin{document}

\input{title_0_5.tex} 
	
%\maketitle

\tableofcontents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Overview}

This document describes extensions and changes in \pml compared to the
previously released version 0.3.1. It is not intended to serve as a proper specification. 
The next public release, due in M42, will come with a fully updated specification document.
The current document introduces the discrete data models, delay differential equations,
extended vector and matrix support and a few new language elements and other corrections/changes.
The appendix \ref{chapter:codeExamples} contains examples of implemented discrete 
data models.

\paragraph{Major extensions in version 0.4}
The following table summarises the changes described in detail in the following chapters.

\begin{center}
\begin{longtable}{lll}
\hline
\hline
\pml element 			&  version $\le$ 0.3.1 			& version 0.4 \\
or modelling aspect 		&							& \\
\hline
Discrete data models 	& \emph{not supported}			& \xelem{Discrete} with child elements such as {\color{red} \scshape{new}} \\
(see \textsection\ref{chapter:DDmodels}) &				& -- \xelem{CountData} with \xelem{CountVariable}, \\
					&							& \xelem{PreviousCountVariable}, \xelem{Dependance},\\
					&							& \xelem{IntensityParameter}, etc.  \\
					&							& and \xelem{PMF} with \xatt{linkFunction} attribute \\
					&							& -- \xelem{CategoricalData} with child elements \\
					&							& such as \xelem{ListOfCategories}, \xelem{CategoryVariable}, \\
					&							& \xelem{InitialStateVariable} (plus few other \\
					&							& variable elements), \xelem{ProbabilityAssignment} and \\
					&							& its child elements: \xelem{Probability},  \xelem{CurrentState}, \\
					&							& \xelem{PreviousState} and \xelem{Condition} \\
					&							& -- \xelem{TimeToEventData} with child elements \\
					&							& \xelem{EventVariable}, \xelem{HazardFunction}, \\
					&							& \xelem{SurvivalFunction}, \xelem{Censoring} and \\
					&							& \xelem{MaximumNumberEvents} \\
\hline
Delay differential equations & \emph{not supported}	& \xelem{Delay} and \xelem{History} {\color{red} \scshape{new}} \\
(DDE) (see \textsection\ref{sec:DDEs})	& 					& with child elements \\ 
					&							& -- \xelem{HistoryValue} and \\
					&							& -- \xelem{HistoryTime}  \\ 
\hline
Extended vector definition & basic support 		 	& \xelem{Vector} with a number of child elements such as\\
 (see \textsection\ref{subsec:vectorType})	&	& \xelem{VectorElements}, \xelem{VectorCell}, \\
					& 							& \xelem{VectorSegment} and attributes \xatt{default}, \xatt{length}  \\ 
\hline
Extended matrix definition & basic support 		 	& \xelem{Matrix} with a number of child elements such as\\
 (see \textsection\ref{subsec:matrixStructure})	& 	& \xelem{MatrixRow}, \xelem{MatrixCell}, \\
					& 							& \xelem{MatrixBlock} and attributes \xatt{matrixType}, \\
					&							& \xatt{diagDefault}, \xatt{offDiagDefault} and others  \\ 
\hline
\caption{Overview of major differences between versions 0.4 and 0.3.1}
\label{figTable:overviewTable}
\end{longtable}
\end{center}


\chapter{Discrete data models}
\label{chapter:DDmodels}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Discrete data models}
%\label{sec:DDmodels}
%

% INPUT
\input{input/introduction_discreteModels}

%\newpage
% INPUT
\input{input/minimalInformation_discreteModels}

%\newpage
% INPUT
\input{input/pharmml_codeTemplates}

%\newpage
%% INPUT
%\input{input/modelsOverview}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Other extensions and changes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Delay differential equations}
\label{sec:DDEs}

The following new elements extend the current ODE structure:
\begin{itemize}
\item
\xelem{Delay} element with two arguments
\begin{itemize}
\item
$y$, a model variable
\item
$\tau$, discrete delay, can be a numerical value or a symbol
\end{itemize}
Then the typical delay expression such as $y(t-\tau)$ would be encoded as
\lstset{language=XML}
\begin{lstlisting}
                    <ct:Delay>
                        <ct:SymbRef symbIdRef="y"/>
                        <ct:DelayVariable>
                            <ct:SymbRef blkIdRef="pm1" symbIdRef="tau"/>
                        </ct:DelayVariable>
                    </ct:Delay>
\end{lstlisting}
with \xatt{tau} defined in the parameter model \emph{pm1}.
\item
\xelem{History} element where the past of a variable is defined for $t \le t_0$. 
It comes with two child elements
\begin{itemize}
\item
\xelem{HistoryValue} stands for past/historical value of a variable $y$, denoted by $y_0$.
\item
\xelem{HistoryTime} stands for the end time, $t_0$, of the history definition. 
By default, history is defined for $t\le t_0$.
\end{itemize}
\end{itemize}

\subsection{\pml code -- basic example}
Based on example from \cite{MLXTRANforMonolix:2014}.

\begin{align}
& \frac{dA}{dt} = r - c \times A \times B - k \times A \nonumber \\
& \frac{dB}{dt} = c \times A \times B - A(t-d) \nonumber 
\end{align}
with history $A_0 = r/k$ and $B_0 = 0$ for $t \le 5$.

\lstset{language=XML}
\begin{lstlisting}
<StructuralModel blkId="sm1">
    <ct:DerivativeVariable symbId="A">
        <ct:Assign>
            <math:Equation>
                <math:Binop op="minus">
                    <ct:SymbRef blkIdRef="pm1" symbIdRef="r"/>
                    <math:Binop op="minus">
                        <math:Binop op="times">
                            <ct:SymbRef blkIdRef="pm1" symbIdRef="c"/>
                            <math:Binop op="times">
                                <ct:SymbRef symbIdRef="A"/>
                                <ct:SymbRef symbIdRef="B"/>
                            </math:Binop>
                        </math:Binop>
                        <math:Binop op="times">
                            <ct:SymbRef blkIdRef="pm1" symbIdRef="k"/>
                            <ct:SymbRef symbIdRef="A"/>
                        </math:Binop>
                    </math:Binop>
                </math:Binop>
            </math:Equation>
        </ct:Assign>
        <ct:IndependentVariable>
            <ct:SymbRef symbIdRef="t"/>
        </ct:IndependentVariable>
        <ct:History>
            <ct:HistoryValue>
                <ct:Assign>
                    <math:Equation>
                        <math:Binop op="divide">
                            <ct:SymbRef blkIdRef="pm1" symbIdRef="r"/>
                            <ct:SymbRef blkIdRef="pm1" symbIdRef="k"/>
                        </math:Binop>
                    </math:Equation>
                </ct:Assign>
            </ct:HistoryValue>
            <ct:HistoryTime>
                <ct:Assign>
                    <ct:Real>5</ct:Real>
                </ct:Assign>
            </ct:HistoryTime>
        </ct:History>
    </ct:DerivativeVariable>
    
    <ct:DerivativeVariable symbId="B">
        <ct:Assign>
            <math:Equation>
                <math:Binop op="minus">
                    <math:Binop op="times">
                        <ct:SymbRef blkIdRef="pm1" symbIdRef="c"/>
                        <math:Binop op="times">
                            <ct:SymbRef symbIdRef="A"/>
                            <ct:SymbRef symbIdRef="B"/>
                        </math:Binop>
                    </math:Binop>
                    <ct:Delay>
                        <ct:SymbRef symbIdRef="A"/>
                        <ct:SymbRef blkIdRef="pm1" symbIdRef="d"/>
                    </ct:Delay>
                </math:Binop>
            </math:Equation>
        </ct:Assign>
        <ct:IndependentVariable>
            <ct:SymbRef symbIdRef="t"/>
        </ct:IndependentVariable>
        <ct:History>
            <ct:HistoryValue>
                <ct:Assign>
                    <ct:Real>0</ct:Real>
                </ct:Assign>
            </ct:HistoryValue>
            <ct:HistoryTime>
                <ct:Assign>
                    <ct:Real>5</ct:Real>
                </ct:Assign>
            </ct:HistoryTime>
        </ct:History>
    </ct:DerivativeVariable>
</StructuralModel>
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Vectors and Matrices -- reloaded}
\label{sec:vectorsAndMatrices}
 \pml has been equipped with vector support and version 0.3.1 introduced additionally 
 the concept of a matrix for the purpose of encoding correlation/covariance matrices. 
Unfortunately, both structures turned out to be insufficient. The vectors were not ready 
to accept other than numerical entries and both vectors and matrices could not be
indexed. Version 0.4 solves these issues. The schema for these two elements is based
on two standards, one dealing with mathematical notation, MathML \cite{mathml3:2010}, 
and another one with data mining models, PMML \cite{pmml:2014}, and comes with 
a wide range of features enabling flexible handling of vectors and matrices via a 
flexible indexing schema.

\begin{figure}[htbp]
\centering
 \includegraphics[width=160mm]{pics/VectorMatrixOverview.jpg}
\caption{Vector and matrix -- vocabulary and structure overview.}
\label{fig:vectorMatrix}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vector structure with examples {\color{red} \scshape{*updated}}}
\label{subsec:vectorType}
Vectors are defined to be column vectors. Row vectors can be created by taking
the transpose (with the \emph{transpose} operation still to be defined) of a column vector. 

\subsubsection{Populating vectors}
\begin{itemize}
\item
Elements
\begin{itemize}
\item
\xelem{VectorElements} is used to define all vector elements without indexing and takes any 
combination of the following items
\begin{itemize}
\item
\xelem{Scalar} and/or \xelem{SymbRef}
\item
\xelem{Equation} -- vector elements can contain expressions  {\color{red} \scshape{NEW}}
\item
\xelem{Sequence}
\end{itemize}
\item
\xelem{VectorCell} is used to define single elements of the vector by specifying
\begin{itemize}
\item
\xelem{CellIndex} {\color{red} \scshape{renamed}} 
\item
\xelem{Scalar}, \xelem{SymbRef} or
\item
\xelem{Equation} -- vector cells can also contain expressions {\color{red} \scshape{NEW}}
\end{itemize}
\item
\xelem{VectorSegment} allows to encode $n$ consecutive elements using the 
\begin{itemize}
\item
\xelem{SegmentStartIndex} {\color{red} \scshape{renamed}} -- marks the start index within a vector
\item
\xelem{SegmentLength} --  the length of the segment and
\item
\xelem{VectorElements} as explained above.
\end{itemize}
\item
all indexes can contain expressions  {\color{red} \scshape{NEW}}
\end{itemize}
\item
Attributes
\begin{itemize}
\item
\xatt{default} stands for the value of not explicitly specified elements -- necessary when 
sparse vectors are encoded using \xelem{VectorCell} or \xelem{VectorSegment}
\item
\xatt{length} of the vector -- required in certain situations, see \xatt{default} comments above.
\end{itemize}
\end{itemize}
Table \ref{tab:vectorsComparison} show two examples how you can encode vectors.

\begin{table}[ht!]
\setlength{\tabcolsep}{10pt}
\begin{center}
\begin{tabular}{ll}
  \hline
  \hline
 \pml version $\le$ 0.3.1 &  \pml version 0.4 \\
  \hline
% \multicolumn{2}{c}{encoding [0,2,0,0,5,0,0,0,0,0]}  \\
%  \hline
  \lstset{language=XML}
\begin{lstlisting}
<ct:Vector>
    <ct:Real>0</ct:Real>
    <ct:Real>2</ct:Real>
    <ct:Real>0</ct:Real>
    <ct:Real>0</ct:Real>
    <ct:SymbRef symbIdRef="fifthElement"/>
    <ct:Real>0</ct:Real>
    <ct:Real>0</ct:Real>
    <ct:Real>0</ct:Real>
    <ct:Real>0</ct:Real>
    <ct:Real>0</ct:Real>
</ct:Vector>
\end{lstlisting}
&
\lstset{language=XML}
\begin{lstlisting}
<ct:Vector length="10">
    <ct:VectorElements>
        <ct:Real>0</ct:Real>
        <ct:Real>2</ct:Real>
        <ct:Real>0</ct:Real>
        <ct:Real>0</ct:Real>
        <ct:SymbRef symbIdRef="fifthElement"/>
        <ct:Real>0</ct:Real>
        <ct:Real>0</ct:Real>
        <ct:Real>0</ct:Real>
        <ct:Real>0</ct:Real>
        <ct:Real>0</ct:Real>
    </ct:VectorElements>
</ct:Vector>
\end{lstlisting}  
\\
& OR
\\
--
&
\lstset{language=XML}
\begin{lstlisting}
<ct:Vector default="0" length="10">
    <ct:VectorCell>
        <ct:VectorIndex>
            <ct:Int>2</ct:Int>
        </ct:VectorIndex>
        <ct:Real>2</ct:Real>
    </ct:VectorCell>
    <ct:VectorCell>
        <ct:VectorIndex>
            <ct:Int>5</ct:Int>
        </ct:VectorIndex>
        <ct:SymbRef symbIdRef="fifthElement"/>
    </ct:VectorCell>
</ct:Vector>
\end{lstlisting} 
\\
%\hline
% \multicolumn{2}{c}{encoding [1,1,3,4,5,6,1,1,1,1]}  \\
%\hline
%-- & \lstset{language=XML}
%\begin{lstlisting}
%<ct:Vector default="1" length="10">
%    <ct:VectorSegment>
%        <ct:StartIndex>3</ct:StartIndex>
%        <ct:EndIndex>6</ct:EndIndex>
%    </ct:VectorSegment>
%</ct:Vector>
%\end{lstlisting} \\
  \hline
  \end{tabular}
\vspace{-1.5em}
\caption{Comparison of vector support in the current and previous version of PharmML. In the first case a 
sparse vector [0,2,0,0,5,0,0,0,0,0] is encoded illustrating the new structure with 
\xelem{VectorElements} and \xelem{VectorCell}.  
%In the second case the vector 
%[1,1,3,4,5,6,1,1,1,1] is encoded using the \xelem{VectorSegment} element. 
In versions $\le$ 0.3.1 all vector elements had to be listed whereas the new version 
offers a \xatt{default} attribute which can be used to avoid unwanted repetitions.}
\label{tab:vectorsComparison}
\end{center}
\end{table}

\subsubsection{Reading vectors}
Once a vector is assigned, we need a mechanism for the readout of vector
elements. This is done with the \xelem{VectorSelector} element. Additionally to the 
vocabulary we used before, we have the \xelem{Head} and \xelem{Tail} methods, i.e.
two ways to extract the first or last few elements which number can be specified
explicitly. The following child elements allow flexible access to any vector element
\begin{itemize}
\item
\xelem{SymbRef} identifies the vector of interest (mandatory)
\item
\xelem{Head} allows to select any number of elements starting with the first one
\item
\xelem{Tail} allows to select any number of elements counted from the last one
\item
\xelem{Cell} is used to pick one element
\item
\xelem{Segment} allows to select a segment of a vector
\end{itemize}
For example, we would like to perform the following assignment 
\begin{align}
& m = a + V2[5] \nonumber
\end{align}
i.e. to add parameter $a$ to the fifth element of vector $V2$. 
The following code shows how this is done. 

\lstset{language=XML}
\begin{lstlisting}
            <SimpleParameter symbId="m">
                <ct:Assign>
                    <math:Equation>
                        <math:Binop op="plus">
                            <ct:SymbRef symbIdRef="a"/>
                            <ct:VectorSelector>
                                <ct:SymbRef symbIdRef="V2"/>
                                <ct:Cell>
                                    <ct:Int>5</ct:Int>
                                </ct:Cell>
                            </ct:VectorSelector>
                        </math:Binop>
                    </math:Equation>
                </ct:Assign>
            </SimpleParameter>
\end{lstlisting}
Now a more complex selection scenario using all available \xelem{VectorSelector} child 
elements: \xelem{Head}, \xelem{Index}, \xelem{Segment} and \xelem{Tail}. In this case it is 
assumed that vector V2 has 25 elements and we want to select only those specified by the
following indexes $i=1:3,\;6:8,\;11,\;18:20,\;22,\;24:25.$
\lstset{language=XML}
\begin{lstlisting}
            <SimpleParameter symbId="n">
                <ct:Assign>
                    <math:Equation>
                        <ct:VectorSelector>
                            <ct:SymbRef symbIdRef="V2"/>
                            <ct:Head><ct:Int>3</ct:Int></ct:Head>
                            <ct:Segment>
                                <ct:StartIndex><ct:Int>6</ct:Int></ct:StartIndex>
                                <ct:SegmentLength><ct:Int>3</ct:Int></ct:SegmentLength>
                            </ct:Segment>
                            <ct:Cell><ct:Int>11</ct:Int></ct:Cell>
                            <ct:Segment>
                                <ct:StartIndex><ct:Int>18</ct:Int></ct:StartIndex>
                                <ct:SegmentLength><ct:Int>3</ct:Int></ct:SegmentLength>
                            </ct:Segment>
                            <ct:Cell><ct:Int>22</ct:Int></ct:Cell>
                            <ct:Tail><ct:Int>2</ct:Int></ct:Tail>
                        </ct:VectorSelector>
                    </math:Equation>
                </ct:Assign>
            </SimpleParameter>
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Matrix structure with examples {\color{red} \scshape{*updated}}}
\label{subsec:matrixStructure}
Similarly to the vector structure there are a few alternative options to encode a matrix.
Note, that for now matrices are allowed in the \xelem{Correlation} element only. Their use
will be extended to handle covariance matrices of multivariate distributions and objects in the 
Standardised Input/Output Model to be introduced in a future release.

\subsubsection{Populating matrices}
\begin{itemize}
\item
Elements
\begin{itemize}
\item
\xelem{MatrixRow} is used to define the matrix row-by-row using
\begin{itemize}
\item
\xelem{RowIndex} (optional) element followed by 
\item
\xelem{Scalar} and/or \xelem{SymbRef}
\item
\xelem{Sequence}
\item
\xelem{Equation} -- row elements can be expressions {\color{red} \scshape{NEW}}.
\end{itemize}
\item
\xelem{MatrixCell} is useful for matrices with few non-zero elements
\begin{itemize}
\item
mandatory elements \xelem{CellRow} and 
\item
\xelem{CellColumn} followed by
\item
\xelem{Scalar} or \xelem{SymbRef}
\item
\xelem{Equation} -- cells can contain expressions  {\color{red} \scshape{NEW}}.
\end{itemize}
\item
\xelem{MatrixBlock} is useful for matrices with non-zero blocks using
\begin{itemize}
\item
\xelem{BlockStartRow} and \xelem{BlockStartColumn} indexes followed by 
a combination of 
\item
\xelem{BlockRow} and/or \xelem{BlockCell} elements, which have the same child elements 
as \xelem{MatrixRow} and \xelem{MatrixCell}, respectively
\item
block attributes which are identical to those of the matrix (listed below) with 
the exception of \xatt{matrixType}
\end{itemize}
\item
all indexes can contain expressions  {\color{red} \scshape{NEW}}.
\end{itemize}
\item
Attributes
\begin{itemize}
\item
\xatt{matrixType} allows to simplify the matrix encoding with following possible values
\begin{itemize}
\item
\xatt{Any} -- no requirements on the matrix.
\item
\xatt{Diagonal} -- only the diagonal values have to be specified, the rest is 
by definition zero.
\item
\xatt{LowerTriangular}/\xatt{UpperTriangular} -- only diagonal and off-diagonal
matrix elements below or above the diagonal are non-zero and have to be 
specified, respectively.
\item
\xatt{Symmetric} -- due to symmetry only the off-diagonal matrix elements 
below or above the diagonal have to be specified.
\end{itemize}
\item
\xatt{numbCols, numbRows} matrix dimensions -- required for sparse matrices, see 
default attributes comments below.
\item
\xatt{diagDefault} the default value on the diagonal -- required when 
sparse matrices are encoded using \xelem{MatrixCell} or \xelem{MatrixBlock}. 
Must be numerical.
\item
\xatt{offDiagDefault}  the default off-diagonals value -- see comments above.
\item
\xatt{symbId} -- (optional) identifier for the matrix.
\end{itemize}


\end{itemize}
If \xelem{MatrixCell} is used the attributes \xatt{matrixType}, \xatt{diagDefault} and 
\xatt{offDiagDefault} can or have to used, dependent on the matrix content. These two 
options are demonstrated with the following matrix, $\Sigma$,
\label{subsec:matrixType}
\begin{align}
\Sigma = 
  \begin{bmatrix} 
  1 & \Sigma_{12} & 0 & 0 \\
  0 & 1 & \Sigma_{23} & 0 \\
  \Sigma_{31} & 0 & 1 & 0 \\
  0 & 0 & 0 & \Sigma_{44} \nonumber \end{bmatrix} 
\end{align}

\subsubsection{Implementation of $\Sigma$ as full matrix}
This is a straightforward implementation of every matrix element explicitly using
the \xelem{MatrixRow} elements.  

  \lstset{language=XML}
\begin{lstlisting}
                <!-- omitted <Correlation> tag -->
                <ct:Assign>
                    <ct:Matrix symbId="Sigma" matrixType="Any">
                        <ct:MatrixRow>
                            <ct:RowIndex><ct:Int>1</ct:Int></ct:RowIndex>
                            <ct:Real>1</ct:Real>
                            <ct:SymbRef symbIdRef="Sigma12"/>
                            <ct:Real>0</ct:Real>
                            <ct:Real>0</ct:Real>
                        </ct:MatrixRow>
                        <ct:MatrixRow>
                            <ct:RowIndex><ct:Int>2</ct:Int></ct:RowIndex>
                            <ct:Real>0</ct:Real>
                            <ct:Real>1</ct:Real>
                            <ct:SymbRef symbIdRef="Sigma23"/>
                            <ct:Real>0</ct:Real>
                        </ct:MatrixRow>
                        <ct:MatrixRow>
                            <ct:RowIndex><ct:Int>3</ct:Int></ct:RowIndex>
                            <ct:SymbRef symbIdRef="Sigma31"/>
                            <ct:Real>0</ct:Real>
                            <ct:Real>1</ct:Real>
                            <ct:Real>0</ct:Real>
                        </ct:MatrixRow>
                        <ct:MatrixRow>
                            <ct:RowIndex><ct:Int>4</ct:Int></ct:RowIndex>
                            <ct:Real>0</ct:Real>
                            <ct:Real>0</ct:Real>
                            <ct:Real>0</ct:Real>
                            <ct:SymbRef symbIdRef="Sigma44"/>
                        </ct:MatrixRow>
                    </ct:Matrix>
                </ct:Assign>
\end{lstlisting}
 
\subsubsection{Implementation of $\Sigma$ as sparse matrix}
Here the $\Sigma$ matrix is implemented using \xelem{MatrixCell} elements.
More specifically only four values have to be stored. The test is encoded using 
\xatt{diagDefault} and \xatt{offDiagDefault} attributes.

\lstset{language=XML}
\begin{lstlisting}
                <!-- omitted <Correlation> block -->
                <ct:Assign>
                    <ct:Matrix symbId="Sigma" matrixType="Any" diagDefault="1" offDiagDefault="0">
                        <ct:MatrixCell>
                            <ct:CellRow><ct:Int>1</ct:Int></ct:CellRow>
                            <ct:CellColumn><ct:Int>2</ct:Int></ct:CellColumn>
                            <ct:SymbRef symbIdRef="Sigma12"/>
                        </ct:MatrixCell>
                        <ct:MatrixCell>
                            <ct:CellRow><ct:Int>2</ct:Int></ct:CellRow>
                            <ct:CellColumn><ct:Int>3</ct:Int></ct:CellColumn>
                            <ct:SymbRef symbIdRef="Sigma23"/>
                        </ct:MatrixCell>
                        <ct:MatrixCell>
                            <ct:CellRow><ct:Int>3</ct:Int></ct:CellRow>
                            <ct:CellColumn><ct:Int>1</ct:Int></ct:CellColumn>
                            <ct:SymbRef symbIdRef="Sigma31"/>
                        </ct:MatrixCell>
                        <ct:MatrixCell>
                            <ct:CellRow><ct:Int>4</ct:Int></ct:CellRow>
                            <ct:CellColumn><ct:Int>4</ct:Int></ct:CellColumn>
                            <ct:SymbRef symbIdRef="Sigma44"/>
                        </ct:MatrixCell>
                    </ct:Matrix>
                </ct:Assign>
\end{lstlisting}  
Note the use of the attributes \xatt{diagDefault} and \xatt{offDiagDefault}
set with either 1 or 0, respectively, which makes the matrix encoding 
very efficient.

\subsubsection{Example 1 -- Covariance matrix with expressions  {\color{red} \scshape{*new example}}}
The elements of a matrix can contain arbitrary expressions. For example, the following covariance matrix
\begin{align}
\Sigma = 
  \begin{bmatrix} 
  	\sigma_V^2  			& \rho\; \sigma_V \sigma_k \\
        \rho\; \sigma_V \sigma_k   	& \sigma_V^2 \nonumber \\
\end{bmatrix} 
\end{align}
is easily implemented as the following code shows

\lstset{language=XML}
\begin{lstlisting}
            <Correlation>
                <ct:VariabilityReference>
                    <ct:SymbRef blkIdRef="modelVar" symbIdRef="indiv"/>
                </ct:VariabilityReference>
                <Matrix matrixType="Any">
                    <ct:MatrixRow>
                        <ct:RowIndex><ct:Int>1</ct:Int></ct:RowIndex>
                        <math:Equation>
                            <math:Binop op="power">
                                <ct:SymbRef symbIdRef="sigma_V"/>
                                <ct:Real>2</ct:Real>
                            </math:Binop>
                        </math:Equation>
                        <math:Equation>
                            <math:Binop op="times">
                                <ct:SymbRef symbIdRef="rho"/>
                                <math:Binop op="times">
                                    <ct:SymbRef symbIdRef="sigma_V"/>
                                    <ct:SymbRef symbIdRef="sigma_k"/>
                                </math:Binop>
                            </math:Binop>
                        </math:Equation>
                    </ct:MatrixRow>
                    <ct:MatrixRow>
                        <ct:RowIndex><ct:Int>2</ct:Int></ct:RowIndex>
                        <math:Equation>
                            <math:Binop op="times">
                                <ct:SymbRef symbIdRef="rho"/>
                                <math:Binop op="times">
                                    <ct:SymbRef symbIdRef="sigma_V"/>
                                    <ct:SymbRef symbIdRef="sigma_k"/>
                                </math:Binop>
                            </math:Binop>
                        </math:Equation>
                        <math:Equation>
                            <math:Binop op="power">
                                <ct:SymbRef symbIdRef="sigma_k"/>
                                <ct:Real>2</ct:Real>
                            </math:Binop>
                        </math:Equation>
                    </ct:MatrixRow>
                </Matrix>
            </Correlation>
\end{lstlisting}  



\subsubsection{Example 2 -- \emph{face} matrix}
Figure \ref{fig:faceMatrix} shows how a sparse matrix can be encoded in an
efficient way using a combination of
\begin{itemize}
\item
\xelem{MatrixBlock}
\item
\xelem{MatrixCell} and
\item
\xelem{MatrixRow}
\end{itemize}
elements. More specifically, the use of two 2x2-blocks, three cells and one matrix row 
is sufficient to encode the hypothetical \emph{face} matrix because the rest 
can be handled with attributes. Figure \ref{fig:faceMatrix} and the code
next to it shows how the elements are defined. Attributes \xatt{diagDefault} 
and \xatt{offDiagDefault} are both set to 1.
Note that the \xelem{RowIndex} of the block's rows are specified relative to 
the block start coordinates, \xelem{BlockStartRow} and \xelem{BlockStartColumn}.
Consequently, the first block row consisting of two 'X' symbols has the index 1, 
the second has the index 2. In contrast the last row is defined using \xelem{RowIndex} 
relative to the main matrix. The attributes \xatt{numbRows} and \xatt{numbCols} 
of the matrix are required due to its sparse nature.


\begin{figure}
\centering
\begin{minipage}[c]{.48\textwidth}
\centering
 \includegraphics[width=75mm]{pics/faceMatrix.jpg}
\caption{Matrix example consisting of two blocks, three cells and one row.
They contain either numerical values or variables names. All other elements 
are defined but the attributes \xatt{diagDefault} and \xatt{offDiagDefault}, 
here both set to 1. \xelem{RowIndex} of the blocks are specified relative to 
the block start coordinates while the indexes of the cells and full matrix rows 
are absolute. The attributes \xatt{numbRows} and \xatt{numbCols} of the
matrix are required due to its sparse nature.}
\label{fig:faceMatrix}
\end{minipage}
\begin{minipage}[c]{.44\textwidth}
\lstset{language=XML}
\begin{lstlisting}
<Correlation deviationMatrixType="CovMatrix">
    <ct:VariabilityReference>
        <ct:SymbRef symbIdRef="subject"/>
    </ct:VariabilityReference>
    <Matrix symbId="faceMatrix" matrixType="Any" 
    	diagDefault="1" offDiagDefault="1">
        <!-- Left eye block -->
        <ct:MatrixBlock>
            <ct:BlockStartRow>
                <ct:Int>2</ct:Int>
            </ct:BlockStartRow>
            <ct:BlockStartColumn>
                <ct:Int>2</ct:Int>
            </ct:BlockStartColumn>
            <ct:BlockRow>
                <ct:RowIndex>
                  <ct:Int>1</ct:Int>
                </ct:RowIndex>
                <ct:SymbRef symbIdRef="X"/>
                <ct:SymbRef symbIdRef="X"/>
            </ct:BlockRow>
            <ct:BlockRow>
                <ct:RowIndex>
                   <ct:Int>2</ct:Int>
                </ct:RowIndex>
                <ct:SymbRef symbIdRef="X"/>
                <ct:SymbRef symbIdRef="X"/>
            </ct:BlockRow>
        </ct:MatrixBlock>
        <!-- Right eye block -->
        <ct:MatrixBlock>
            <ct:BlockStartRow>
                <ct:Int>2</ct:Int>
            </ct:BlockStartRow>
            <ct:BlockStartColumn>
                <ct:Int>7</ct:Int>
            </ct:BlockStartColumn>
            <!-- omitted - identical to left block -->
        </ct:MatrixBlock>
        <!-- Nose blocks -->
        <ct:MatrixCell>
            <ct:CellRow>
                <ct:Int>5</ct:Int>
            </ct:CellRow>
            <ct:CellColumn>
                <ct:Int>5</ct:Int>
            </ct:CellColumn>
            <ct:Real>0</ct:Real>
        </ct:MatrixCell>
        <!-- omitted middle cell -->
        <ct:MatrixCell>
            <ct:CellRow>
                <ct:Int>7</ct:Int>
            </ct:CellRow>
            <ct:CellColumn>
                <ct:Int>5</ct:Int>
            </ct:CellColumn>
            <ct:Real>0</ct:Real>
        </ct:MatrixCell>
        <!-- Mouth row -->
        <ct:MatrixRow default="5">
            <ct:RowIndex>
              <ct:Int>8</ct:Int>
            </ct:RowIndex>
        </ct:MatrixRow>
    </Matrix>
</Correlation>
\end{lstlisting}
\end{minipage}
\end{figure}





%\subsubsection{Example 3 -- Lower/upper triangular matrix}
%...to be finished
%

\subsubsection{Example 3 -- Block-diagonal matrix}
A typical matrix application example is the specification of the
correlation matrix of the random effects, see a screenshot for the 
Monolix GUI, Figure \ref{fig:corrMatrixMonolix}, \cite{MLXTRAN4.3.2Specification:2014}. 
This is another example of a sparse matrix with the blocks as the only non-zero 
elements of the matrix. Using attributes \xatt{diagDefault} and \xatt{offDiagDefault} 
makes the encoding an easy task leaving only the blocks to be defined explicitly. 

\begin{figure}[htb!]
\centering
  \includegraphics[width=90mm]{pics/corrMatrixMonolix}
 \caption{Correlation matrix encoded using the Monolix GUI, \cite{MLXTRAN4.3.2Specification:2014}.}
 \label{fig:corrMatrixMonolix}
\end{figure}

\lstset{language=XML}
\begin{lstlisting}
<Correlation deviationMatrixType="CorrMatrix">
    <ct:VariabilityReference>
        <ct:SymbRef symbIdRef="subject"/>
    </ct:VariabilityReference>
    <Matrix symbId="Omega" matrixType="Any" diagDefault="1" offDiagDefault="0">
        <!-- tlag, ka - block -->
        <ct:MatrixBlock>
            <ct:BlockStartRow><ct:Int>1</ct:Int></ct:BlockStartRow>
            <ct:BlockStartColumn><ct:Int>1</ct:Int></ct:BlockStartColumn>
            <ct:BlockRow>
                <ct:RowIndex><ct:Int>1</ct:Int></ct:RowIndex>
                <ct:Int>1</ct:Int><ct:Int>1</ct:Int>
            </ct:BlockRow>
            <ct:BlockRow>
                <ct:RowIndex><ct:Int>2</ct:Int></ct:RowIndex>
                <ct:Int>1</ct:Int><ct:Int>1</ct:Int>
            </ct:BlockRow>
        </ct:MatrixBlock>
        <!-- V, CL - block -->
        <ct:MatrixBlock>
            <ct:BlockStartRow><ct:Int>3</ct:Int></ct:BlockStartRow>
            <ct:BlockStartColumn><ct:Int>3</ct:Int></ct:BlockStartColumn>
            <ct:BlockRow>
                <ct:RowIndex><ct:Int>1</ct:Int></ct:RowIndex>
                <ct:Int>1</ct:Int><ct:Int>1</ct:Int>
            </ct:BlockRow>
            <ct:BlockRow>
                <ct:RowIndex><ct:Int>2</ct:Int></ct:RowIndex>
                <ct:Int>1</ct:Int><ct:Int>1</ct:Int>
            </ct:BlockRow>
        </ct:MatrixBlock>
        <!-- Imax, C50 - block -->
        <ct:MatrixBlock>
            <ct:BlockStartRow><ct:Int>5</ct:Int></ct:BlockStartRow>
            <ct:BlockStartColumn><ct:Int>5</ct:Int></ct:BlockStartColumn>
            <ct:BlockRow>
                <ct:RowIndex><ct:Int>1</ct:Int></ct:RowIndex>
                <ct:Int>1</ct:Int><ct:Int>1</ct:Int>
            </ct:BlockRow>
            <ct:BlockRow>
                <ct:RowIndex><ct:Int>2</ct:Int></ct:RowIndex>
                <ct:Int>1</ct:Int><ct:Int>1</ct:Int>
            </ct:BlockRow>
        </ct:MatrixBlock>
        <!-- gammma, S0, kprog - block -->
        <ct:MatrixBlock>
            <ct:BlockStartRow><ct:Int>7</ct:Int></ct:BlockStartRow>
            <ct:BlockStartColumn><ct:Int>7</ct:Int></ct:BlockStartColumn>
            <ct:BlockRow>
                <ct:RowIndex><ct:Int>1</ct:Int></ct:RowIndex>
                <ct:Int>1</ct:Int><ct:Int>1</ct:Int><ct:Int>1</ct:Int>
            </ct:BlockRow>
            <ct:BlockRow>
                <ct:RowIndex><ct:Int>2</ct:Int></ct:RowIndex>
                <ct:Int>1</ct:Int><ct:Int>1</ct:Int><ct:Int>1</ct:Int>
            </ct:BlockRow>
            <ct:BlockRow>
                <ct:RowIndex><ct:Int>3</ct:Int></ct:RowIndex>
                <ct:Int>1</ct:Int><ct:Int>1</ct:Int><ct:Int>1</ct:Int>
            </ct:BlockRow>
        </ct:MatrixBlock>
    </Matrix>
</Correlation>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Reading matrices}
Once a matrix is assigned, we need a mechanism for the readout of its elements. 
This is done with the \xelem{MatrixSelector} element. The following child elements 
allow flexible access to any matrix element
\begin{itemize}
\item
\xelem{SymbRef} identifies the matrix of interest (mandatory)
\item
\xelem{Cell} is used to pick one element
\item
\xelem{Block} allows to select a block of the matrix
\item
\xelem{Row} allows to select one row of a matrix
\item
\xelem{Column} allows to select one column of a matrix
\end{itemize}
Following code shows few examples of how to access 
\begin{itemize}
\item
single element
\item
single row or
\item
\{flag,ka\} block
\end{itemize}
from the $\Omega$ matrix defined in previous example, see Figure \ref{fig:corrMatrixMonolix}.

\lstset{language=XML}
\begin{lstlisting}
            <!-- extract one element -->
            <SimpleParameter symbId="rho_tlag_ka">
                <ct:Assign>
                    <math:Equation>
                        <ct:MatrixSelector>
                            <ct:SymbRef symbIdRef="Omega"/>
                            <ct:Cell>
                                <ct:RowIndex><ct:Int>1</ct:Int></ct:RowIndex>
                                <ct:ColumnIndex><ct:Int>2</ct:Int></ct:ColumnIndex>
                            </ct:Cell>
                        </ct:MatrixSelector>
                    </math:Equation>
                </ct:Assign>
            </SimpleParameter>
            
            <!-- extract 2nd row -->
            <ct:Variable symbolType="real" symbId="SecondRow">
                <ct:Assign>
                    <math:Equation>
                        <ct:MatrixSelector>
                            <ct:SymbRef symbIdRef="Omega"/>
                            <ct:Row>
                                <ct:Int>2</ct:Int>
                            </ct:Row>
                        </ct:MatrixSelector>
                    </math:Equation>
                </ct:Assign>
            </ct:Variable>
            
            <!-- extract {tlag,ka} block -->
            <ct:Variable symbolType="real" symbId="Rho_tlag_ka">
                <ct:Assign>
                    <math:Equation>
                        <ct:MatrixSelector>
                            <ct:SymbRef symbIdRef="Omega"/>
                            <ct:Block>
                                <ct:BlockStartRow><ct:Int>1</ct:Int></ct:BlockStartRow>
                                <ct:BlockStartColumn><ct:Int>1</ct:Int></ct:BlockStartColumn>
                                <ct:RowsNumber><ct:Int>2</ct:Int></ct:RowsNumber>
                                <ct:ColumnsNumber><ct:Int>2</ct:Int></ct:ColumnsNumber>
                            </ct:Block>
                        </ct:MatrixSelector>
                    </math:Equation>
                </ct:Assign>
            </ct:Variable>
\end{lstlisting}


%\subsection{Typing rules}
%-- Subscripting has the highest precedence compared to any other arithmetic operation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Other changes}
\label{sec:otherChanges}
\subsection{Sum and products using indexes {\color{red} \scshape{*section updated}}}
Sum and product symbols are frequently used in various model formulations, see for 
example section \ref{subsec:categoricalData}. Both have avery similar structure and 
consist of following elements
\begin{itemize}
\item
\xelem{SymbRef} -- to define the variable for which the sum or product is defined. 
\item
\xelem{Equation} -- sum can be defined for any expression {\color{red} \scshape{NEW}}.
\item
\xelem{SumIndex} or \xelem{ProductIndex} -- (optional) identifies the index.
\item
\xelem{LowLimit} and \xelem{UpLimit} -- need to restrict the value of the index.
\item
Similarly, to vectors and matrices, indexes of sum/products can contain expressions {\color{red} \scshape{NEW}}.
\end{itemize}
Table \ref{tab:sumAndProduct} shows two basic examples of the use of sum and
product.

\begin{table}[ht!]
\setlength{\tabcolsep}{25pt}
\begin{center}
\begin{tabular}{ll}
  \hline
  \hline
 Expression &  \pml version 0.4 implementation\\
  \hline
 \multicolumn{2}{c}{Product}  \\
  \hline
$W = \prod_{i=1}^{N} V_i $
&
\lstset{language=XML}
\begin{lstlisting}
<SimpleParameter symbId="W">
    <ct:Assign>
        <math:Equation>
            <ct:Product>
                <math:Equation>
                    <ct:VectorSelector>
                        <ct:SymbRef symbIdRef="V"/>
                        <ct:Cell>
                            <ct:SymbRef symbIdRef="i"/>
                        </ct:Cell>
                    </ct:VectorSelector>
                </math:Equation>
                <ct:ProductIndex>
                    <ct:SymbRef symbIdRef="i"/>
                </ct:ProductIndex>
                <ct:LowLimit>
                    <ct:Int>1</ct:Int>
                </ct:LowLimit>
                <ct:UpLimit>
                    <ct:Int>10</ct:Int>
                </ct:UpLimit>
            </ct:Product>
        </math:Equation>
    </ct:Assign>
</SimpleParameter>
\end{lstlisting}
\\
  \hline
 \multicolumn{2}{c}{Sum}  \\
  \hline
$M = \sum_{i=1}^{N} V_i $
&
\lstset{language=XML}
\begin{lstlisting}
<SimpleParameter symbId="M">
    <ct:Assign>
        <math:Equation>
            <ct:Sum>
                <math:Equation>
                    <ct:VectorSelector>
                        <ct:SymbRef symbIdRef="V"/>
                        <ct:Cell>
                            <ct:SymbRef symbIdRef="i"/>
                        </ct:Cell>
                    </ct:VectorSelector>
                </math:Equation>
                <ct:SumIndex>
                    <ct:SymbRef symbIdRef="i"/>
                </ct:SumIndex>
                <ct:LowLimit>
                    <ct:Int>1</ct:Int>
                </ct:LowLimit>
                <ct:UpLimit>
                    <ct:SymbRef symbIdRef="N"/>
                </ct:UpLimit>
            </ct:Sum>
        </math:Equation>
    </ct:Assign>
</SimpleParameter>
\end{lstlisting}
\\
  \hline
  \end{tabular}
\vspace{-1.5em}
\caption{Implementation examples for sigma sum element, $\sum$, and product, $\prod$.}
\label{tab:sumAndProduct}
\end{center}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Correlation matrix update}
\label{sec:correlationMatrix}
Changes in the matrix were necessary to arrive at a consistent, generic matrix definition.
Previous format and use was determined by the correlation/covariance structure 
requirements only and was too limiting for general use. As explained in section 
\ref{sec:vectorsAndMatrices}, \xatt{matrixType} has been renamed in \xatt{deviationMatrixType}
and relocated to the \xelem{Correlation} element. The original \xatt{matrixType} 
is now populated with the names of general matrix formats. The attribute 
\xatt{deviationMatrixType} is optional and should only be used in connection with matrices.
See Figure \ref{tab:newMatrixStructure} for a comparison of the current and previous deviance 
matrix structure.

\begin{table}[ht!]
\setlength{\tabcolsep}{5pt}
\begin{center}
\begin{tabular}{ll}
  \hline
Definition in $\leq$ 0.3.1 versions 	& Definition in 0.4 version  \\
  \hline
%			\multicolumn{2}{c}{Mapping in a \xelem{CategoricalData} model}  \\  [.5ex]
  \hline
\lstset{language=XML}
\begin{lstlisting}
<Correlation>
    <ct:VariabilityReference>
        <ct:SymbRef symbIdRef="iiv"/>
    </ct:VariabilityReference>
    <Matrix matrixType="CorrMatrix">
        <ct:MatrixRow>
            <ct:Real>1</ct:Real>
            <ct:Real>2</ct:Real>
        </ct:MatrixRow>
        <ct:MatrixRow>
            <ct:Real>3</ct:Real>
            <ct:Real>4</ct:Real>
        </ct:MatrixRow>
    </Matrix>
</Correlation>
\end{lstlisting}
&
\lstset{language=XML}
\begin{lstlisting}
<Correlation deviationMatrixType="CorrMatrix">
    <ct:VariabilityReference>
        <ct:SymbRef symbIdRef="iiv"/>
    </ct:VariabilityReference>
    <Matrix matrixType="Any">
        <ct:MatrixRow>
            <ct:Real>1</ct:Real>
            <ct:Real>2</ct:Real>
        </ct:MatrixRow>
        <ct:MatrixRow>
            <ct:Real>3</ct:Real>
            <ct:Real>4</ct:Real>
        </ct:MatrixRow>
    </Matrix>
</Correlation>
\end{lstlisting}
\\
  \hline
  \end{tabular}
\vspace{-1.5em}
\caption{Changes in the matrix structure. The new attribute \xatt{deviationMatrixTyp} carries 
now values which were stored by \xatt{matrixType} in previous version, i.e. \{\xatt{CorrMatrix}, 
\xatt{CovMatrix}, \xatt{StDevCorrMatrix}, \xatt{Cholesky}\}. The attribute \xatt{matrixType} is 
now having the general values characterising a matrix, such as: \{\xatt{Any}, \xatt{LowerTriangular}, 
\xatt{UpperTriangular}, \xatt{Diagonal}, \xatt{Symmetric}\}.}
\label{tab:newMatrixStructure}
\end{center}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Categorical data/covariates mapping  {\color{red} \scshape{*table updated}}}
\label{subsec:catDataCovariatesMapping}

As indicated already in section \ref{sec:catDataMapping} the mapping of categories symbols 
as stored in the data set and used in the model is now done in the \xelem{ModellingSteps} 
part of PharmML. The \xelem{CategoryMapping} element is used with attributes
\begin{itemize}
\item
\xatt{dataSymbol} -- the symbol as used the external dataset, e.g. 0/1 for 'SEX' covariates
or \{1,2,3\} for categories of a categorical data model.
\item
\xatt{modelSymbol} -- the symbol as used the model, e.g. F/M for SEX covariates
or \{cat1, cat2, cat3\} for categories of a categorical data model
\end{itemize}
see Table \ref{tab:categoryMapping} for examples.

\begin{table}[ht!]
\setlength{\tabcolsep}{1pt}
\begin{center}
\begin{tabular}{ll}
  \hline
Definition of categories  	& \xelem{CategoryMapping} in \xelem{ColumnMapping} \\
  \hline
\multicolumn{2}{c}{Mapping of discrete data categories \xelem{CategoricalData} model}  \\  [.5ex]
  \hline
\lstset{language=XML}
\begin{lstlisting}
<ObservationModel blkId="om1">
    <CategoricalData ordered="yes">
        <ListOfCategories> 
            <Category symbId="cat1"/>
            <Category symbId="cat2"/>
            <Category symbId="cat3"/>
        </ListOfCategories>
        
        <CategoryVariable symbId="Y"/>
        <!-- omitted the rest -->
\end{lstlisting}
&
\lstset{language=XML}
\begin{lstlisting}
<ColumnMapping>
    <ColumnRef columnIdRef="DV"/>
    <ct:SymbRef blkIdRef="om1" symbIdRef="Y"/>
    <CategoryMapping>
        <Map dataSymbol="1" modelSymbol="cat1"/>
        <Map dataSymbol="2" modelSymbol="cat2"/>
        <Map dataSymbol="3" modelSymbol="cat3"/>
    </CategoryMapping>
</ColumnMapping>

\end{lstlisting}
\\
    \hline
			\multicolumn{2}{c}{Mapping of categories of discrete covariates in \xelem{CovariateModel}}  \\  [.5ex]
  \hline
\lstset{language=XML}
\begin{lstlisting}
<CovariateModel blkId="cm1">
    <Covariate symbId="SEX">
        <Categorical>
          <Category catId="F">
              <Probability>
                  <ct:Real>.55</ct:Real>
              </Probability>
          </Category>                    
          <Category catId="M">
              <Probability>
                  <ct:Real>.45</ct:Real>
              </Probability>
          </Category>
        </Categorical>
    </Covariate>
</CovariateModel>
\end{lstlisting}
&
\lstset{language=XML}
\begin{lstlisting}
<ColumnMapping>
    <ColumnRef columnIdRef="COV"/>
    <ct:SymbRef blkIdRef="cm1" symbIdRef="SEX"/>
    <CategoryMapping>
        <Map dataSymbol="1" modelSymbol="F"/>
        <Map dataSymbol="0" modelSymbol="M"/>
    </CategoryMapping>
</ColumnMapping>
\end{lstlisting}
\\
  \hline
  \end{tabular}
\vspace{-1.5em}
\caption{Examples of category mapping for (top) discrete data categories in the categorical data model. 
(Bottom) mapping of categories of discrete covariates in \xelem{CovariateModel}.}
\label{tab:categoryMapping}
\end{center}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Mapping for categorical data}
%\subsubsection{Mapping for categorical covariates}

%\subsubsection{LhsTransformationType and LRhsTransformationType}
%does it matter for the users?
%- BothSideTransformation
%for 
%1. parameter model of type GaussianModel
%2. observation error of type \xelem{Standard} -  GaussianObsError 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Logarithm notation -- unified}
Previously, two symbols existed to express the natural logarithm, $\log$ and $\ln$. 
To avoid confusions, the $ln$ symbol has been removed. The following logarithm related functions
are now available
\begin{itemize}
\item
$\log$ -- the natural logarithm
\item
$\log$2 - the base-2 (binary) logarithm 
\item
$\log$10 - the base-10 (decadic) logarithm
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Metadata \xatt{id}}
... is now available for every element of the schema. This allows to annotate virtually any 
element of a model.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{New attribute \xatt{implementedBy} in the root element}
The new attribute \xatt{implementedBy} is helpful to keep track on the authorship of 
a PharmML encoded file. 


\lstset{language=XML}
\begin{lstlisting}
<PharmML xmlns="http://www.pharmml.org/2013/03/PharmML"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    ...
    writtenVersion="0.4" implementedBy="JamesBond" id="i1">
    
    <ct:Name>Testing new attribute</ct:Name>
    ...
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Extensions and changes in 0.4.1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Updated mapping of model elements and dataset}
This section aims to describe a consistent way the mapping between several model elements 
can be implemented. Note that because of the lack \marginpar{\HandCuffLeft} of a common 
DDMoRe wide data format, the testing of the mapping implementation bas been limited in 
most cases to the NONMEM dataset although it may also work for MONOLIX data. The latter 
remains to be tested.

%Only for PK macros the mapping is implemented and tested between model and MONOLIX dataset. 
In all cases the mapping between model and the \xelem{TrialDesign} has
been validated and test cases implemented as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subparagraph{Dataset column mapping} uses
%\begin{itemize}
%\item
%\xelem{ColumnMapping} with either
%\begin{itemize}
%\item
%\xelem{ColumnRef} and
%\item
%\xelem{SymbRef}
%\end{itemize}
%\item
%OR \xelem{ColumnMapping} with
%\begin{itemize}
%\item
%\xelem{ColumnRef} and
%\item
%\xelem{TargetMapping} with child(ren)
%\begin{itemize}
%\item
%\xelem{Map} with attributes
%\begin{itemize}
%\item
%\xatt{dataSymbol}
%\item
%\xatt{modelSymbol}
%\item
%\xatt{admNumber}
%\end{itemize}
%\end{itemize}
%\end{itemize}
%\end{itemize}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{\xelem{LookupTable} mapping}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{\xelem{TrialDesign} mapping}
%
%\xelem{TargetMapping} with child(ren)
%\begin{itemize}
%\item
%\xelem{Map} with attributes
%\begin{itemize}
%\item
%\xatt{dataSymbol}
%\item
%\xatt{modelSymbol}
%\item
%\xatt{admNumber}
%\end{itemize}
%\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dosing target mapping}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{ODE based PK model}
Note that in versions $\leq$ 0.4 the \xatt{compartmentNo} attribute 
in the \xelem{DerivativeVariable} was used for the mapping between ODE based model and the dataset. 
It has been replaced by the below described mapping for two reasons. First, to achieve model 
and data separation and second in order to active more consistent mapping definition.

ODEs are one of the main ways to encode PK models. For example, a 1-compartmental IV 
model with linear elimination reads
\begin{align}
\frac{dAc}{dt} &= - k \times Ac  \nonumber
\end{align}
which is encoded in the PharmML as the following code snippet shows
\lstset{language=XML}
\begin{lstlisting}
        <StructuralModel blkId="sm3">
            <ct:DerivativeVariable symbolType="real" symbId="Ac">
                <ct:Assign>
                    <math:Equation>
                        <math:Binop op="times">
                            <math:Uniop op="minus">
                                <ct:SymbRef blkIdRef="pm1" symbIdRef="k"/>
                            </math:Uniop>
                            <ct:SymbRef symbIdRef="Ac"/>
                        </math:Binop>
                    </math:Equation>
                </ct:Assign>
                <!-- omitted details -->
        </StructuralModel>
\end{lstlisting}
The following table shows how the mapping between the target, in this case $Ac$, and 
\xelem{TrailDesing} or NONMEM dataset.
\begin{table}[ht!]
\setlength{\tabcolsep}{1pt}
\begin{center}
\begin{tabular}{ll}
  \hline
\xelem{Activity}/\xelem{TrialDesign}  	& NONMEM dataset \\
  \hline
\lstset{language=XML}
\begin{lstlisting}
<Activity oid="bolusIV"> 
  <Bolus> 
    <DoseAmount inputTarget="derivativeVariable">
      <ct:SymbRef blkIdRef="sm1" symbIdRef="Ac"/>
      <ct:Assign>
        <ct:Real>10</ct:Real>
      </ct:Assign>
   </DoseAmount>
   <DosingTimes>
      <!-- omitted details -->
   </DosingTimes>
 </Bolus>
</Activity>
\end{lstlisting}
&
\lstset{language=XML}
\begin{lstlisting}
<NONMEMdataSet oid="NMoid">

  <ColumnMapping>
    <ds:ColumnRef columnIdRef="CMT"/>
    <ds:TargetMapping blkIdRef="sm1">
      <ds:Map dataSymbol="1" modelSymbol="Ac"/>
    </ds:TargetMapping>
  </ColumnMapping>
    
  <ds:DataSet>

  <!-- omitted details -->
\end{lstlisting}
\\
  \hline
  \end{tabular}
\vspace{-1.5em}
\caption{Mapping rules for PK model encoded as an ODE for \xelem{TrialDesing} and a NONMEM dataset.}
\label{tab:targetMapping1}
\end{center}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Algebraic PK model}
Algebraic functions are used when the explicit solution for PK model is known. For example, a 
1-compartmental oral steady-state administration model with linear elimination, \cite{Bonate:2011fk} 
p.535, reads
\begin{align*}
C_{SS}(t) &= \frac{D}{V}\frac{K_a}{K_a - k} \bigg(\frac{e^{-k (t-t_D)}}{1-e^{-k \tau}}-\frac{e^{-K_a (t-t_D)}}{1-e^{-K_a\tau}}\bigg) 
\end{align*}
which encoded in the PharmML reads
\lstset{language=XML}
\begin{lstlisting}
        <StructuralModel blkId="sm3">
            <!-- Css -->
            <ct:Variable symbolType="real" symbId="Css">
                <ct:Assign>
                    <Equation xmlns="http://www.pharmml.org/2013/03/Maths">
                        <Binop op="times">
                            <Binop op="divide">
                                <ct:SymbRef symbIdRef="D"/>
                                <ct:SymbRef blkIdRef="pm1" symbIdRef="V"/>
                            </Binop>
                            <Binop op="times">
                                <Binop op="divide">
                                    <ct:SymbRef blkIdRef="pm1" symbIdRef="Ka"/>
                                    <Binop op="minus">
                                        <ct:SymbRef blkIdRef="pm1" symbIdRef="Ka"/>
                                        <ct:SymbRef symbIdRef="k"/>
                                    </Binop>
                                </Binop>
                                <!-- omitted details -->
        </StructuralModel>
\end{lstlisting}
In this case the target is the dose parameter, D, and the following table shows how to map it.
\begin{table}[ht!]
\setlength{\tabcolsep}{1pt}
\begin{center}
\begin{tabular}{ll}
  \hline
\xelem{Activity}/\xelem{TrialDesign}  	& NONMEM dataset \\
  \hline
\lstset{language=XML}
\begin{lstlisting}
<Activity oid="bolusOR">
  <Bolus>
    <DoseAmount inputTarget="parameter"> 
      <ct:SymbRef blkIdRef="sm1" symbIdRef="D"/>
      <ct:Assign>
        <ct:Real>100</ct:Real>
      </ct:Assign>
    </DoseAmount>
    <DosingTimes>
      <!-- omitted details -->
    </DosingTimes>
  </Bolus>
</Activity>
\end{lstlisting}
&
\lstset{language=XML}
\begin{lstlisting}
<NONMEMdataSet oid="NMoid">
    
  <!-- omitted details -->
    
  <ColumnMapping>
    <ds:ColumnRef columnIdRef="CMT"/>
      <ds:TargetMapping blkIdRef="sm1">
        <ds:Map dataSymbol="1" modelSymbol="D"/>
      </ds:TargetMapping>
  </ColumnMapping>
    
  <DataSet>
\end{lstlisting}
\\
  \hline
  \end{tabular}
\vspace{-1.5em}
\caption{Mapping rules for PK model encoded as an algebraic equation for \xelem{TrialDesing} and a NONMEM dataset.}
\label{tab:targetMapping2}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{PK macros}
%PK macros are a new option extending the standard encoding ways for PK models. 
%For example, a macro for a 1-comparmental IV model with linear elimination (corresponds to ADVAN1) reads
%\lstset{language=NONMEMdataSet}
%\begin{lstlisting}
%	compartment(cmt=1, amount=Ac, volume=V)
%	iv(adm=1, cmt=1)
%	elimination(cmt=1, k)
%\end{lstlisting}
%which encoded in the proposed PharmML reads
%\lstset{language=XML}
%\begin{lstlisting}
%        <StructuralModel blkId="sm3">
%            <ct:Variable symbolType="real" symbId="Ac"/>
%            
%            <PKmacros>
%                <!-- omitted Compartment macro -->
%                <IV>
%                    <Value argument="adm">
%                        <ct:Int>1</ct:Int>
%                    </Value>
%                    <Value argument="cmt">
%                        <ct:Int>1</ct:Int>
%                    </Value>
%                </IV>
%                <!-- omitted Elimination macro -->
%            </PKmacros>
%        </StructuralModel>
%\end{lstlisting}
%The following table shows how the mapping between the target, in this case the administration 
%number identified with the attribute \xatt{adm} works for \xelem{TrailDesing} and MONOLIX dataset.
%\begin{table}[h!]
%\setlength{\tabcolsep}{1pt}
%\begin{center}
%\begin{tabular}{ll}
%  \hline
%\xelem{Activity}/\xelem{TrialDesign}  	& MONOLIX dataset \\
%  \hline
%\lstset{language=XML}
%\begin{lstlisting}
%<Activity oid="bolusIV">
%    <Bolus>
%        <DoseAmount inputTarget="admType"> 
%            <TargetMapping blkIdRef="sm3">
%                <ds:Map admNumber="1"/>
%            </TargetMapping>
%            <ct:Assign>
%                <ct:Real>100</ct:Real>
%            </ct:Assign>
%        </DoseAmount>
%        <!-- omitted details -->
%    </Bolus>
%</Activity>        
%\end{lstlisting}
%&
%\lstset{language=XML}
%\begin{lstlisting}
%<MONOLIXdataSet oid="MLXoid">
%    
%    <ColumnMapping>
%        <ds:ColumnRef columnIdRef="ADM"/>
%        <ds:TargetMapping blkIdRef="sm1">
%            <ds:Map dataSymbol="1" admNumber="1"/>
%        </ds:TargetMapping>
%    </ColumnMapping>             
%    
%    <DataSet>
%    
%    <!-- omitted details -->
%\end{lstlisting}
%\\
%  \hline
%  \end{tabular}
%\vspace{-1.5em}
%\caption{Mapping rules for macro encoded PK model for \xelem{TrialDesing} and a MONOLIX dataset.}
%\label{tab:targetMapping3}
%\end{center}
%\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Arbitrary model variable}
There are cases when a \emph{forcing function} in form of tabular data is provided and needs to 
be mapped with a model variable. This is the case in the following minimal model of which 
only the relevant equation is shown
\begin{align*}
 \frac{dX(t)}{dt} & = I(t) - Ib
\end{align*}
Here, I(t) is the insulin coming from a \xelem{LookupTable}, which needs to be interpolated in 
order to concert its discrete data into continues signal required by the ODE solver. It is encoded 
in the PharmML as the following code snippet shows
\lstset{language=XML}
\begin{lstlisting}
        <StructuralModel blkId="sm1">
            
            <ct:Variable symbolType="real" symbId="I">
                <ct:Assign>
                    <ct:Interpolation>
                        <ct:Algorithm>linear</ct:Algorithm>
                        <ct:InterpIndepVar>
                            <ct:SymbRef symbIdRef="t"/>
                        </ct:InterpIndepVar>
                    </ct:Interpolation>
                </ct:Assign>
            </ct:Variable>
            
            <!-- dX(t)/dt= I(t) - Ib -->
            <ct:DerivativeVariable symbolType="real" symbId="X">
                <ct:Assign>
                <!-- omitted details -->

        </StructuralModel>
\end{lstlisting}

\begin{table}[ht!]
\setlength{\tabcolsep}{1pt}
\begin{center}
\begin{tabular}{ll}
  \hline
\xelem{LookupTable}/\xelem{Activity}/\xelem{TrialDesign}  	& MONOLIX dataset \\
  \hline
\lstset{language=XML}
\begin{lstlisting}
<Activity oid="targetingInsulin">
  <LookupTable>
    <Target inputTarget="variable">
      <ColumnMapping>
        <ds:ColumnRef columnIdRef="INS"/>
        <ct:SymbRef blkIdRef="sm1" symbIdRef="I"/>
      </ColumnMapping>
    </Target>
    <ds:DataSet>
\end{lstlisting}
&
\lstset{language=XML}
\begin{lstlisting}
<NONMEMdataSet oid="NMoid">
    
  <ColumnMapping>
    <ds:ColumnRef columnIdRef="INS"/>
    <ct:SymbRef blkIdRef="sm1" symbIdRef="I"/>
  </ColumnMapping>
    
  <ds:DataSet>
\end{lstlisting}
\\
  \hline
  \end{tabular}
\vspace{-1.5em}
\caption{Mapping rules for arbitrary variables with input stored using \xelem{LookupTable} or a standard 
NONMEM dataset.}
\label{tab:targetMapping4}
\end{center}
\end{table}

\subparagraph{Note} Full PharmML model examples are attached to this release.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Observations mapping}
No further changes are required for the observation mapping which follows rules as 
described above. In the case when multiple DV need to be mapped the element 
\xelem{MultipleDVMapping} can be used as described in \cite{Swat:2014aa}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Covariates mapping}
The mapping of categorical covariates has been modified already for the version 0.4 and has been
described in Section \ref{subsec:catDataCovariatesMapping}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Categorical data mapping}
The mapping of categorical covariates has been modified already for the version 0.4 and has been
described in Section \ref{subsec:catDataCovariatesMapping}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Occasions mapping}

The \xelem{TrialDesign} uses the \xelem{ObservationsEvent} element to define the occasions 
mapping. In the case of datasets, the occasions are stored as covariates and need additional 
mapping to the appropriate variability level defined in the \xelem{VariabilityLevel} encoded in 
\pml as
\lstset{language=XML}
\begin{lstlisting}
        <VariabilityModel blkId="modelVar" type="parameterVariability">
            <Level symbId="indiv"/>
            <Level symbId="iov1">
                <ParentLevel>
                    <ct:SymbRef symbIdRef="indiv"/>
                </ParentLevel>
            </Level>
        </VariabilityModel>
\end{lstlisting}
The mapping can then be defined using \xelem{ColumnMapping} element as 
described in the beginning of this section for many other model elements, i.e.
\lstset{language=XML}
\begin{lstlisting}
<NONMEMdataSet oid="NMoid">
    <!-- omitted details -->
    <ColumnMapping>
        <ds:ColumnRef columnIdRef="OCC"/>
        <ct:SymbRef blkIdRef="modelVar" symbIdRef="iov1"/>
    </ColumnMapping>
    
    <ds:DataSet>
        <ds:Definition>
            <ds:Column columnId="ID" columnType="id" valueType="id" columnNum="1"/>
            <ds:Column columnId="TIME" columnType="time" valueType="real" columnNum="2"/>
            <!-- omitted columns -->
            <ds:Column columnId="OCC" columnType="covariate" valueType="id" columnNum="7"/>
        </ds:Definition>
        <!-- omitted details -->
    </ds:DataSet>
</NONMEMdataSet>
\end{lstlisting}
The column OCC is mapped to \xatt{iov1} symbol, defined in \xatt{modelVar}, denoting the inter-occasion variability level.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\xelem{CovariateModel} and \xelem{ParameterModel} updates}

\subsubsection{Transforming and referencing covariates}
The \xelem{CovariateModel} allows to define a transformation, distribution and/or 
interpolation for a continues covariate. However, the previous \pml version didn't allow the 
distinction between the untransformed covariate and its transformed version. This had two 
disadvantages
\begin{itemize}
\item
multiple covariate models had to be defined if a covariate was to be used in parameter models 
with different transformations.
\item
the covariate reference was ambiguous.
\end{itemize}
For example the two following parameter models use both bodyweight as a covariate with and without scaling 
\begin{align*}
 \log(CL_i) & = \log(CL_{pop}) + \Big( \frac{BW}{70} \Big)^{0.75} + \eta_{CL}\\
 \log(V_i) & = \log(V_{pop}) + BW + \eta_V 
\end{align*}
for which two covariate model blocks would normally be required. Instead, now only one covariate model
is necessary as shown in the following snippet

\lstset{language=XML}
\begin{lstlisting}
        <CovariateModel blkId="cm1">
            <Covariate symbId="W">
                <Continuous>
                    <TransformedCovariate symbId="W70"/>
                    <Transformation>
                        <math:Equation>
                            <math:Binop op="divide">
                                <ct:SymbRef symbIdRef="W"/>
                                <ct:Real>70</ct:Real>
                            </math:Binop>
                        </math:Equation>
                    </Transformation>
                </Continuous>
            </Covariate>
        </CovariateModel>
\end{lstlisting}
One needs to define only one transformation for CL while the parameter model for V will just 
refer to the original covariate.

\begin{table}[ht!]
\setlength{\tabcolsep}{5pt}
\begin{center}
\begin{tabular}{ll}
  \hline
parameter model for CL 	& parameter model for V  \\
  \hline
  \hline
\lstset{language=XML}
\begin{lstlisting}
<IndividualParameter symbId="CL">
  <GaussianModel>
      <LinearCovariate>
        <PopulationParameter>
          <ct:Assign>
            <ct:SymbRef symbIdRef="CL_pop"/>
         </ct:Assign>
        </PopulationParameter>
        <Covariate>
          <ct:SymbRef symbIdRef="W70"/>
          <FixedEffect>
            <ct:Real>0.75</ct:Real>
          </FixedEffect>
        </Covariate>
      </LinearCovariate>
      <RandomEffects>
        <ct:SymbRef symbIdRef="eta_CL"/>
      </RandomEffects>
  </GaussianModel>
</IndividualParameter>
\end{lstlisting}
&
\lstset{language=XML}
\begin{lstlisting}
<IndividualParameter symbId="V">
  <GaussianModel>
      <LinearCovariate>
        <PopulationParameter>
          <ct:Assign>
            <ct:SymbRef symbIdRef="V_pop"/>
          </ct:Assign>
        </PopulationParameter>
        <Covariate>
          <ct:SymbRef symbIdRef="W"/>
        </Covariate>
      </LinearCovariate>
      <RandomEffects>
        <ct:SymbRef symbIdRef="eta_V"/>
      </RandomEffects>
  </GaussianModel>
</IndividualParameter>
\end{lstlisting}
\\
  \hline
  \end{tabular}
\vspace{-1.5em}
\caption{Changes in parameter model. Fixed effect can be numerical (left) or omitted if 
not required or equal to 0 (right).}
\label{tab:fixedEffectsChanges}
\end{center}
\end{table}


\subsubsection{Redundant fixed effects}
Previous example made use of another improvement.
Because the fixed effect $\beta_V$ is fixed and equal to 1 it has been simply ignored.
To allow this the \xelem{FixedEffect} element, which was required in previous versions, has 
been made optional.

\subsubsection{Numerical fixed effects}
\lstset{language=XML}
\begin{lstlisting}
            <IndividualParameter symbId="CL">
                <GaussianModel>
                    <Transformation>log</Transformation>
                    <LinearCovariate>
                        <PopulationParameter>
                            <ct:Assign>
                                <ct:SymbRef symbIdRef="CL_pop"/>
                            </ct:Assign>
                        </PopulationParameter>
                        <Covariate>
                            <ct:SymbRef symbIdRef="W70"/>
                            <FixedEffect>
                                <ct:Real>0.75</ct:Real>
                            </FixedEffect>
                        </Covariate>
                    </LinearCovariate>
                    <RandomEffects>
                        <ct:SymbRef symbIdRef="eta_CL"/>
                    </RandomEffects>
                </GaussianModel>
            </IndividualParameter>
\end{lstlisting}

        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Scaling dosing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Scaling within \xelem{TrialDesign}}
Covariate adjustment of a dose was already possible in version 0.2.1 when the definion of the 
trial design and the mapping of the associated data with a model had to be encoded in the \xelem{TrialDesign}. 
The scaling of a dose with the bodyweight, BW,
\begin{align*}
 & Dose_{scaled} = Dose \times BW
\end{align*}
has to be encoded in the according \xelem{Activity} element 
\lstset{language=XML}
\begin{lstlisting}
            <Activity oid="bolusIV"> 
                <Bolus> 
                    <DoseAmount inputTarget="variable">
                        <ct:SymbRef blkIdRef="sm1" symbIdRef="Ac"/>
                        <ct:Assign>
                            <math:Equation>
                                <math:Binop op="times">
                                    <ct:Real>10</ct:Real>
                                    <ct:SymbRef blkIdRef="cm1" symbIdRef="W"/>
                                </math:Binop>
                            </math:Equation>
                        </ct:Assign>
                    </DoseAmount>
                    <!-- omitted details -->

                </Bolus>
            </Activity>            
\end{lstlisting}
However, dose scaling when a dataset is used was not possible so far and must be defined additionally
and is described in the next section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Scaling when mapping dataset}
We consider for a change a slightly more complex scaling law, i.e. one talking into account the creatinine 
clearance, CLcr, and dosing regimen, REGI, as a categorical covariate
\begin{align*}
 & Dose_{scaled} = Dose \times \Big(\frac{CLcr}{80}\Big)^{\theta_{clcr}} \times (1+\theta_{regi})^{REGI}
\end{align*}
which is implemented as the following snippet shows
\lstset{language=XML}
\begin{lstlisting}
<ds:DataSet>
    <ds:Definition>
        <ds:Column columnId="ID" columnType="id" valueType="id" columnNum="1"/>
        <ds:Column columnId="TIME" columnType="idv" valueType="real" columnNum="2"/>
        <!-- omitted details -->
        <ds:Column columnId="CLCR" columnType="covariate" valueType="real" columnNum="5"/>
        <ds:Column columnId="REGI" columnType="covariate" valueType="int" columnNum="6"/>
        <ds:Column columnId="DOSE" columnType="dose" valueType="real" columnNum="7">
            <ds:Transformation>
                <math:Equation>
                    <math:Binop op="times">
                        <ds:ColumnRef columnIdRef="DOSE"/>
                        <math:Binop op="times">
                            <math:Binop op="power">
                                <math:Binop op="divide">
                                    <ct:SymbRef blkIdRef="cm1" symbIdRef="CLCR"/>
                                    <ct:Real>80</ct:Real>
                                </math:Binop>
                                <ct:SymbRef symbIdRef="theta_clcr"/>
                            </math:Binop>
                            <math:Binop op="power">
                                <math:Binop op="plus">
                                    <ct:Real>1</ct:Real>
                                    <ct:SymbRef symbIdRef="theta_regi"/>
                                </math:Binop>
                                <ct:SymbRef blkIdRef="cm1" symbIdRef="REGI"/>
                            </math:Binop>
                        </math:Binop>
                    </math:Binop>
                </math:Equation>
            </ds:Transformation>
        </ds:Column>
        <!-- omitted details -->
</ds:DataSet>
\end{lstlisting}
%but the scaling when a dataset is used must be defined additionally.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extensions/changes in vectors and matrices}
As indicated with red font in Sections \ref{subsec:vectorType} and \ref{subsec:matrixStructure},
elements of matrices and vectors can be defined as arbitrary expressions. This mean the that 
\xelem{Equation} is a new child element of \xelem{VectorElements}, \xelem{VectorCell}, 
\xelem{MatrixRow} and \xelem{MatrixCell}. Moreover, all indexes can contain expressions as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vector elements renamed}
Two vector elements have been renamed for consistency reasons
\begin{itemize}
\item
\xelem{VectorIndex} $\longrightarrow$ \xelem{CellIndex}
\item
\xelem{SegmentIndex} $\longrightarrow$ \xelem{SegmentStartIndex}
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Other changes}
\label{sec:otherChanges2}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Optional \xelem{Population} element}
In the case a single subject model is considered the \xelem{Population} element
in which subjects are described is redundant but had been required but the schema in \pml 
versions $\leq$ 0.4. This has been relaxed now and the element is optional.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Additional link function}
Discrete data models use so called link functions, see more details in Section \ref{subsec:mi_discreteModels}. 
Two additional are defined 
\begin{itemize}
\item
$\rm loglog$ -- the log-log function
\begin{align}
& f(\mu) = \log(-\log(\mu)) \nonumber
\end{align}
\item
$\rm comploglog$ -- the complementary log-log function
\begin{align}
& f(\mu) = \log(-\log(1-\mu)) \nonumber
\end{align}
\end{itemize}
which will make encoding of according models simpler. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Extensions in sums and products elements}

Although all of the standard and complex models, Section \ref{subsec:mmCategoricalData}, are encodable 
in PharmML 0.4, the implementation was hampered by the missing expression assignments to 
indexes and sum/product arguments -- this is fixed now with indexes being equipped with \xelem{Equation} 
as child element.

Additionally to extensions marked with red in Section \ref{subsec:vectorType} and \ref{subsec:matrixStructure},
sums and products can be defined using over arbitrary expressions, e.g.
\begin{align}
& W = \beta_0 + \sum_{i=1}^{10} \beta_i x_i \nonumber
\end{align}
which looks as follows in PharmML
\lstset{language=XML}
\begin{lstlisting}
<SimpleParameter symbId="W">
    <ct:Assign>
        <math:Equation>
            <ct:Product>
                <math:Equation>
                    <math:Binop op="plus">
                        <ct:VectorSelector>
                            <ct:SymbRef symbIdRef="beta"/>
                            <ct:Cell>
                                <ct:Int>0</ct:Int>
                            </ct:Cell>
                        </ct:VectorSelector>
                        <math:Binop op="times">
                            <ct:VectorSelector>
                                <ct:SymbRef symbIdRef="beta"/>
                                <ct:Cell>
                                    <ct:SymbRef symbIdRef="i"/>
                                </ct:Cell>
                            </ct:VectorSelector>
                            <ct:VectorSelector>
                                <ct:SymbRef symbIdRef="x"/>
                                <ct:Cell>
                                    <ct:SymbRef symbIdRef="i"/>
                                </ct:Cell>
                            </ct:VectorSelector>
                        </math:Binop>
                    </math:Binop>
                </math:Equation>
                <ct:ProductIndex>
                    <ct:SymbRef symbIdRef="i"/>
                </ct:ProductIndex>
                <ct:LowLimit>
                    <ct:Int>1</ct:Int>
                </ct:LowLimit>
                <ct:UpLimit>
                    <ct:Int>10</ct:Int>
                </ct:UpLimit>
            </ct:Product>
        </math:Equation>
    </ct:Assign>
</SimpleParameter>
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discrete data -- missing element in \xelem{SimulationStep} added}
The \xelem{Observation} element within \xelem{SimulationStep} is used to define the time 
points at which an observable should be simulated, as specified by the user. So far we only 
had a space holder for continues data. This has been now extended to discrete data by defining 
new element \xelem{Discrete} as the following code shows
\lstset{language=XML}
\begin{lstlisting}
        <mstep:SimulationStep oid="simStep1">
            <mstep:Observations>
                <mstep:Timepoints>
                    <ct:Sequence>
                        <ct:Begin><ct:Real>1</ct:Real></ct:Begin>
                        <ct:StepSize><ct:Real>1</ct:Real></ct:StepSize>
                        <ct:End><ct:Real>10</ct:Real></ct:End>
                    </ct:Sequence>
                </mstep:Timepoints>
                <mstep:Discrete>
                    <ct:SymbRef blkIdRef="om1" symbIdRef="y"/>
                </mstep:Discrete>
            </mstep:Observations>
        </mstep:SimulationStep>
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Defining estimation and simulations type}
So far the description or a particular operation carried out during simulation or estimation
tasks were limited to few options, e.g. in the \xatt{opType} attribute within the \xelem{Operation}
tag the allowed options were \xatt{estPop}, \xatt{estIndiv} and \xatt{estFIM}. 

This restriction is now relaxed and the user can use an arbitrary string as the following code snippet shows
\lstset{language=XML}
\begin{lstlisting}
        <EstimationStep oid="estTask1">
            <TargetToolReference>
                <ct:OidRef oidRef="MLXoid"/>
            </TargetToolReference>
            
            <ParametersToEstimate>
                <!-- omitted details -->
            </ParametersToEstimate>

            <Operation order="1" opType="estPop"/>
            <Operation order="2" opType="estIndiv"/>
            <Operation order="3" opType="And now for something completely different"/>
         </EstimationStep>
\end{lstlisting}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix

\chapter{Code examples}
\label{chapter:codeExamples}
 
%% INPUT
%\input{input/code_countData}
%
%\newpage
%% INPUT
%\input{input/code_categoricalData}
%
%\newpage
%% INPUT
%\input{input/code_timeToEventData}
%


\bibliographystyle{plain}
\bibliography{pharmml-specification}
\end{document}





%TEMPLATES 
%% 1. Template for table with figures
%\begin{figure}[htbp]
%\centering
%\begin{tabular}{cc}
% \includegraphics[width=80mm]{pics/pic1} & 
% \includegraphics[width=80mm]{pics/pic2} \\
% \includegraphics[width=80mm]{pics/pic3} &
% \includegraphics[width=80mm]{pics/pic4}
%\end{tabular}
%\caption{about the figure}
%\label{figTable:labelText}
%\end{figure}

%\begin{table}[ht]
%\begin{center}
%\begin{tabular}{rrrrrrrrrrr}
%  \hline
% & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ 
%  \hline
%1 & 0.24 & -1.47 & -0.56 & 0.24 & 0.71 & 1.23 & 0.44 & 0.40 & 1.10 & 1.84 \\ 
%   \hline
%\end{tabular}
%\end{center}
%\end{table}
 

%\begin{figure}[htb!]
%\centering
%  \includegraphics[width=105mm]{}
% \caption{}
% \label{fig:myplot}
%\end{figure}

%PIECE-WISE
%f(z) =     \left\{ \begin{array}{rcl}
%         value1 & \mbox{for} & condition1 \\ 
%         value1 & \mbox{for} & condition1
%             \end{array}\right.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FOR LOOPS and GRUENENTHAL MODEL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsection{For loops for categorical models}
%Loops make implementation of model simpler, especially when multiple categories have to be considered.
%Following ordered categorical model for NRS pain score, based on \cite{Wang:2014}, 
%\begin{align}
%& \text{for j = 1 to m} \nonumber \\
%  & \quad logit( P(PS <= cat_j) ) = \sum_{k=0}^{m} \beta_k + \theta_{base}(PS(t=0)-4.2) + fp(t) + f(drug) \nonumber \\ 
%& \text{end} \nonumber
%\end{align}
%has been implemented using a for-loop as the following code for the observation model shows. Note that 
%model parameters to be estimated and categories have been formulated as vectors, $\beta$ and $categoryVector$,
%respectively. Compared to the original formulation, see Figure \ref{fig:GruenenthalModel}, the subject 
%index \emph{i} of the observation variable $PS$ has been omitted.
%\lstset{language=XML}
%\begin{lstlisting}
%<ObservationModel blkId="om1">
%    <Discrete>
%        <CategoricalData>
%            <SimpleParameter symbId="m"/>
%            <SimpleParameter symbId="beta">
%                <ct:Assign>
%                    <ct:Vector>
%                        <ct:VectorElements>
%                            <ct:SymbRef blkIdRef="pm1" symbIdRef="beta_1"/>
%                            <!-- omitted beta_2 .. beta_{m-1} -->
%                            <ct:SymbRef blkIdRef="pm1" symbIdRef="beta_m"/>
%                        </ct:VectorElements>
%                    </ct:Vector>
%                </ct:Assign>
%            </SimpleParameter>
%            
%            <SimpleParameter symbId="categoryVector">
%                <ct:Assign>
%                    <ct:Vector>
%                        <ct:VectorElements>
%                            <ct:SymbRef symbIdRef="cat1"/>
%                            <!-- omitted cat_1 ... cat_{m-1} -->
%                            <ct:SymbRef symbIdRef="catm"/>
%                        </ct:VectorElements>
%                    </ct:Vector>
%                </ct:Assign>
%            </SimpleParameter>
%            
%            <ct:Variable symbolType="int" symbId="i"/>
%            <ct:Variable symbolType="int" symbId="j"/>
%            <ct:Variable symbolType="int" symbId="k"/>
%            
%            <ListOfCategories> 
%                <Category symbId="cat0"/>
%                <!-- omitted other categories -->
%                <Category symbId="catm"/>
%            </ListOfCategories>
%            
%            <CategoryVariable symbId="PS"/>
%
%        <!-- 
%        for j=1 to m
%          logit(P(PS_j<=cat_j))=\Sigma_{k=0}^{m}beta_k+theta_base*(PS_0-4.2)+fp(t)+f(drug) 
%        end 
%        -->
%            <ForLoop>
%                <ct:ProbabilityAssignment>
%                    <Probability linkFunction="logit">
%                        <math:LogicBinop op="leq">
%                            <ct:SymbRef symbIdRef="PS"/>
%                            <ct:VectorSelector>
%                                <ct:SymbRef symbIdRef="categoryVector"/>
%                                <ct:Cell>
%                                    <ct:SymbRef symbIdRef="j"/>
%                                </ct:Cell>
%                            </ct:VectorSelector>
%                        </math:LogicBinop>
%                    </Probability>
%                    <ct:Assign>
%                        <math:Equation>
%                            <math:Binop op="plus">
%                                <math:Binop op="plus">
%                                    <math:Binop op="plus">
%                                        <ct:Sum>
%                                            <math:Equation>
%                                                <ct:VectorSelector>
%                                                    <ct:SymbRef symbIdRef="beta"/>
%                                                    <ct:Cell>
%                                                        <ct:SymbRef symbIdRef="k"/>
%                                                    </ct:Cell>
%                                                </ct:VectorSelector>
%                                            </math:Equation>
%                                            <ct:SumIndex>
%                                                <ct:SymbRef symbIdRef="k"/>
%                                            </ct:SumIndex>
%                                            <ct:LowLimit>
%                                                <ct:Int>0</ct:Int>
%                                            </ct:LowLimit>
%                                            <ct:UpLimit>
%                                                <ct:SymbRef symbIdRef="m"/>
%                                            </ct:UpLimit>
%                                        </ct:Sum>
%                                        <math:Binop op="times">
%                                            <ct:SymbRef symbIdRef="theta_base"/>
%                                            <math:Binop op="minus">
%                                                <ct:VectorSelector>
%                                                    <ct:SymbRef symbIdRef="PS"/>
%                                                    <ct:Cell>
%                                                        <ct:Int>0</ct:Int>
%                                                    </ct:Cell>
%                                                </ct:VectorSelector>
%                                                <ct:Real>4.2</ct:Real>
%                                            </math:Binop>
%                                        </math:Binop>
%                                    </math:Binop>
%                                    <!-- function fp(t) -->
%                                    <math:FunctionCall>
%                                        <ct:SymbRef symbIdRef="fp"/>
%                                        <math:FunctionArgument symbId="p_max">
%                                            <ct:SymbRef blkIdRef="pm1" symbIdRef="Pmax"/>
%                                        </math:FunctionArgument>
%                                        <math:FunctionArgument symbId="k_plc">
%                                            <ct:SymbRef blkIdRef="pm1" symbIdRef="Kplc"/>
%                                        </math:FunctionArgument>
%                                        <math:FunctionArgument symbId="time">
%                                            <ct:SymbRef symbIdRef="t"/>
%                                        </math:FunctionArgument>
%                                    </math:FunctionCall>
%                                </math:Binop>
%                                <!-- function f(drug) -->
%                                <math:Binop op="divide">
%                                    <math:Binop op="times">
%                                        <ct:SymbRef blkIdRef="pm1" symbIdRef="Emax"/>
%                                        <ct:SymbRef blkIdRef="sm1" symbIdRef="C_M"/>
%                                    </math:Binop>
%                                    <math:Binop op="plus">
%                                        <ct:SymbRef blkIdRef="pm1" symbIdRef="EC50"/>
%                                        <ct:SymbRef blkIdRef="sm1" symbIdRef="C_M"/>
%                                    </math:Binop>
%                                </math:Binop>
%                            </math:Binop>
%                        </math:Equation>
%                    </ct:Assign>
%                </ct:ProbabilityAssignment>
%                <ct:LoopIndex>
%                    <ct:SymbRef symbIdRef="j"/>
%                </ct:LoopIndex>
%                <ct:StartIndex>
%                    <ct:Int>1</ct:Int>
%                </ct:StartIndex>
%                <ct:EndIndex>
%                    <ct:SymbRef symbIdRef="m"/>
%                </ct:EndIndex>
%            </ForLoop>
%        </CategoricalData>
%    </Discrete>
%</ObservationModel>
%\end{lstlisting}
%The full model is provided in the example folder as \emph{categorical\_GruenenthalModel.xml}
%
%
%\begin{figure}[htb!]
%\centering
%  \includegraphics[width=40mm,angle=-90]{pics/CategoricalWithSumModel.jpg}
% \caption{}
% \label{fig:GruenenthalModel}
%\end{figure}


\subsubsection{PharmML code -- 2 alternative implementations}
\lstset{language=XML}
\begin{lstlisting}
<PharmML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	...
    xmlns:mml="http://www.pharmml.org/2013/03/PharmML"
    implementedBy="MJS" writtenVersion="0.4" id="i1">

    <IndependentVariable symbId="t"/>
    
    <ModelDefinition id="i3" xmlns="http://www.pharmml.org/2013/03/ModelDefinition">
        
        <ParameterModel blkId="pm1">
            <SimpleParameter symbId="ka"/>
            <SimpleParameter symbId="V"/>
            <SimpleParameter symbId="CL"/>
            
            <SimpleParameter symbId="B0"/>
            <SimpleParameter symbId="B1"/>
            <SimpleParameter symbId="B2"/>
            
            <SimpleParameter symbId="POP_BETA"/>
        </ParameterModel>
        
        <StructuralModel blkId="sm1">
           <!-- PK model encoded by macros -->
            <ct:Variable symbolType="real" symbId="Cp"/>
            
            <ct:Variable symbolType="real" symbId="EDRUG">
                <!-- EDRUG = POP_BETA*Cp -->
            </ct:Variable>
            
	<!-- compartment(cmt=1, amount=Ac, volume=V) 
            oral(adm=1, cmt=1, ka)
            elimination(cmt=1, k)-->
            <PKmacros>
                <Compartment>
                    <Value argument="cmt">
                        <ct:Int>1</ct:Int>
                    </Value>
                    <Value argument="concentration">
                        <ct:SymbRef symbIdRef="Cp"/>
                    </Value>
                    <Value argument="volume">
                        <ct:SymbRef symbIdRef="V"/>
                    </Value>
                </Compartment>
                <Oral>
                    <Value argument="adm">
                        <ct:Int>1</ct:Int>
                    </Value>
                    <Value argument="cmt">
                        <ct:Int>1</ct:Int>
                    </Value>
                    <Value>
                        <ct:SymbRef blkIdRef="pm1" symbIdRef="ka"/>
                    </Value>
                </Oral>
                <Elimination>
                    <Value argument="cmt">
                        <ct:Int>1</ct:Int>
                    </Value>
                    <Value argument="k">
                        <ct:Assign>
                            <math:Equation>
                                <math:Binop op="divide">
                                    <ct:SymbRef blkIdRef="pm1" symbIdRef="CL"/>
                                    <ct:SymbRef blkIdRef="pm1" symbIdRef="V"/>
                                </math:Binop>
                            </math:Equation>
                        </ct:Assign>
                    </Value>
                </Elimination>
            </PKmacros>
        </StructuralModel>
        
        <!-- MLXTRAN style -->
        <ObservationModel blkId="om1">
            <Discrete>
                <CategoricalData ordered="yes">
                    
                    <ListOfCategories> 
                        <Category symbId="cat0"/>
                        <Category symbId="cat1"/>
                        <Category symbId="cat2"/>
                        <Category symbId="cat3"/>
                    </ListOfCategories>
                    
                    <CategoryVariable symbId="y"/>
                    
                    <!-- logit( P(y <= 0) ) = EDRUG + B0 --> 
                    <ProbabilityAssignment>
                        <Probability linkFunction="logit">
                            <math:LogicBinop op="leq">
                                <ct:SymbRef symbIdRef="y"/>
                                <ct:SymbRef symbIdRef="cat0"/>
                            </math:LogicBinop>
                        </Probability>
                        <ct:Assign>
                            <math:Equation>
                                <math:Binop op="plus">
                                    <ct:SymbRef blkIdRef="sm1" symbIdRef="EDRUG"/>
                                    <ct:SymbRef blkIdRef="pm1" symbIdRef="B0"/>
                                </math:Binop>
                            </math:Equation>
                        </ct:Assign>
                    </ProbabilityAssignment>
                    
                    <!-- logit( P(y <= 1) ) = EDRUG + B0 + B1 --> 
                    <ProbabilityAssignment>
                        <Probability linkFunction="logit">
                            <math:LogicBinop op="leq">
                                <ct:SymbRef symbIdRef="y"/>
                                <ct:SymbRef symbIdRef="cat1"/>
                            </math:LogicBinop>
                        </Probability>
                        <ct:Assign>
                            <math:Equation>
                                <math:Binop op="plus">
                                    <ct:SymbRef blkIdRef="sm1" symbIdRef="EDRUG"/>
                                    <math:Binop op="plus">
                                        <ct:SymbRef symbIdRef="B0"/>
                                        <ct:SymbRef symbIdRef="B1"/>
                                    </math:Binop>
                                </math:Binop>
                            </math:Equation>
                        </ct:Assign>
                    </ProbabilityAssignment>
                    
                    <!-- logit( P(y <= 2) ) = EDRUG + B0 + B1 + B2 --> 
                    <ProbabilityAssignment>
                        <Probability linkFunction="logit">
                            <math:LogicBinop op="leq">
                                <ct:SymbRef symbIdRef="y"/>
                                <ct:SymbRef symbIdRef="cat2"/>
                            </math:LogicBinop>
                        </Probability>
                        <ct:Assign>
                            <math:Equation>
                                <math:Binop op="plus">
                                    <ct:SymbRef blkIdRef="sm1" symbIdRef="EDRUG"/>
                                    <math:Binop op="plus">
                                        <ct:SymbRef symbIdRef="B0"/>
                                        <math:Binop op="plus">
                                            <ct:SymbRef symbIdRef="B1"/>
                                            <ct:SymbRef symbIdRef="B2"/>
                                        </math:Binop>
                                    </math:Binop>
                                </math:Binop>
                            </math:Equation>
                        </ct:Assign>
                    </ProbabilityAssignment>
                </CategoricalData>
            </Discrete>
        </ObservationModel>
        
        <!-- NONMEM style -->
        <ObservationModel blkId="om2">
            <Discrete>
                <CategoricalData ordered="yes">
                    
                    <ct:Variable symbolType="real" symbId="A0">
                        <!-- EDURG + B0 -->
                    </ct:Variable>
                    <ct:Variable symbolType="real" symbId="A1">
                        <!-- EDURG + B0 + B1 -->
                    </ct:Variable>
                    <ct:Variable symbolType="real" symbId="A2">
                        <!-- EDURG + B0 + B1 + B2 -->
                    </ct:Variable>

                    <ct:Variable symbolType="real" symbId="CP0">
                        <!-- 1 / (1 + exp(-A0)) -->
                    </ct:Variable>
                    <ct:Variable symbolType="real" symbId="CP1">
                        <!-- 1 / (1 + exp(-A1)) -->
                    </ct:Variable>
                    <ct:Variable symbolType="real" symbId="CP2">
                        <!-- 1 / (1 + exp(-A2)) -->
                    </ct:Variable>

                    <ct:Variable symbolType="real" symbId="P0">
                        <!-- CP0 -->
                    </ct:Variable>
                    <ct:Variable symbolType="real" symbId="P1">
                        <!-- CP1 - CP0 -->
                    </ct:Variable>
                    <ct:Variable symbolType="real" symbId="P2">
                        <!-- CP2 - CP1 -->
                    </ct:Variable>
                    <ct:Variable symbolType="real" symbId="P3">
                        <!-- 1 - CP2 -->
                    </ct:Variable>
                    
                    <ListOfCategories> 
                        <Category symbId="cat0"/>
                        <Category symbId="cat1"/>
                        <Category symbId="cat2"/>
                        <Category symbId="cat3"/>
                    </ListOfCategories>
                    
                    <CategoryVariable symbId="y"/>
                    
                    <PMF linkFunction="identity">
                        <CategoricalDistribution xmlns="http://www.uncertml.org/3.0" 
                            definition="http://www.uncertml.org/...">
                            <categoryProb definition="http://www.uncertml.org/...">
                                <name>Probability for cat0</name>
                                <probability>
                                    <var varId="P0"/>
                                </probability>
                            </categoryProb>
                            <categoryProb definition="http://www.uncertml.org/...">
                                <name>Probability for cat1</name>
                                <probability>
                                    <var varId="P1"/>
                                </probability>
                            </categoryProb>
                            <categoryProb definition="http://www.uncertml.org/...">
                                <name>Probability for cat2</name>
                                <probability>
                                    <var varId="P2"/>
                                </probability>
                            </categoryProb>
                            <categoryProb definition="http://www.uncertml.org/...">
                                <name>Probability for cat3</name>
                                <probability>
                                    <var varId="P3"/>
                                </probability>
                            </categoryProb>
                        </CategoricalDistribution>
                    </PMF>
                </CategoricalData>
            </Discrete>
        </ObservationModel>
        
    </ModelDefinition>
    
    <mstep:ModellingSteps>
        
        <mstep:NONMEMdataSet oid="NMoid">
            
            <mstep:ColumnMapping>
                <ds:ColumnRef columnIdRef="TIME"/>
                <ct:SymbRef symbIdRef="t"/>
            </mstep:ColumnMapping>
            
            <mstep:ColumnMapping>
                <ds:ColumnRef columnIdRef="DV"/>
                <ct:SymbRef blkIdRef="om1" symbIdRef="y"/>
                <ds:CategoryMapping>
                    <ds:Map dataSymbol="0" modelSymbol="cat0"/>
                    <ds:Map dataSymbol="1" modelSymbol="cat1"/>
                    <ds:Map dataSymbol="2" modelSymbol="cat2"/>
                    <ds:Map dataSymbol="3" modelSymbol="cat3"/>
                </ds:CategoryMapping>
            </mstep:ColumnMapping>
            
            <ds:DataSet>
                <ds:Definition>
                    <ds:Column columnId="ID" columnType="id" valueType="id" columnNum="1"/>
                    <ds:Column columnId="TIME" columnType="time" valueType="real" columnNum="2"/>
                    <ds:Column columnId="DV" columnType="dv" valueType="real" columnNum="3"/>
                </ds:Definition>
                <ds:ImportData oid="importData">
                    <ds:path>myFile.csv</ds:path>
                    <ds:format>CSV</ds:format>
                    <ds:delimiter>COMMA</ds:delimiter>
                </ds:ImportData>
            </ds:DataSet>
        </mstep:NONMEMdataSet>
        
        <mstep:EstimationStep oid="estStep1">
            
            <mstep:TargetToolReference>
                <ct:OidRef oidRef="NMoid"/>
            </mstep:TargetToolReference>
            
            <mstep:ParametersToEstimate>
                <mstep:ParameterEstimation>
                    <ct:SymbRef symbIdRef="B0"/>
                    <mstep:InitialEstimate>
                        <ct:Real>1</ct:Real>
                    </mstep:InitialEstimate>
                </mstep:ParameterEstimation>
                
                <mstep:ParameterEstimation>
                    <ct:SymbRef symbIdRef="B1"/>
                    <mstep:InitialEstimate>
                        <ct:Real>0.6</ct:Real>
                    </mstep:InitialEstimate>
                </mstep:ParameterEstimation>
                
                <mstep:ParameterEstimation>
                    <ct:SymbRef symbIdRef="B2"/>
                    <mstep:InitialEstimate>
                        <ct:Real>0.6</ct:Real>
                    </mstep:InitialEstimate>
                </mstep:ParameterEstimation>
                
            </mstep:ParametersToEstimate>
            
            <mstep:Operation order="1" opType="estPop"/>
        </mstep:EstimationStep>
    </mstep:ModellingSteps>
</PharmML>
